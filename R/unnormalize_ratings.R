#' Un-normalize rating table
#'
#' @param normalized normalization information generated by \code{\link{normalize_ratings}}
#' @param ratings \code{data.table} of ratings. Should contain 3 columns: userI_id (id of user, character), item_id (id of item, character) and predicted_rating (predicted rating of item by user, integer or numeric)
#'
#' @return a ratings \code{data.table} after un-normalization
#'
#' @details
#' Need to apply this after prediction is made using a model built from normalized ratings
#'
#' @examples
#' set.seed(1)
#' in_train <- rep(TRUE, nrow(MovieLense))
#' in_train[sample(1:nrow(MovieLense), size = length(unique(MovieLense$user_id)) * 5)] <- FALSE
#'
#' MovieLense_train <- MovieLense[(in_train)]
#'
#' ratings <- normalize_ratings(MovieLense_train)
#' model <- build_slopeone(ratings$ratings)
#'
#' predictions <- predict_slopeone(model, MovieLense[(!in_train), c(1, 2), with = FALSE], ratings$ratings)
#' real_ratings <- unnormalize_ratings(normalized = ratings, ratings = predictions)
#'
#' rmse <- sqrt(mean((real_ratings$predicted_rating - MovieLense[(!in_train)]$rating) ^ 2))
#'
#' @import data.table
#'
#' @export


unnormalize_ratings <- function(normalized, ratings) {
  ratings$predicted_rating <- ifelse(is.na(ratings$predicted_rating), 0,
                                     ratings$predicted_rating)
  ratings$predicted_rating <- ratings$predicted_rating + normalized$global
  setkey(normalized$user, user_id)
  user_mean <- normalized$user[J(ratings$user_id), ]$mean_rating
  ratings$predicted_rating <- ratings$predicted_rating +
    ifelse(!is.na(user_mean), user_mean, 0)
  setkey(normalized$item, item_id)
  item_mean <- normalized$item[J(ratings$item_id), ]$mean_rating
  ratings$predicted_rating <- ratings$predicted_rating +
    ifelse(!is.na(item_mean), item_mean, 0)
  return(ratings)
}
